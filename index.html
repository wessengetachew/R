
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The 6ab±a±b Problem: Modular Lattice Explorer</title>
    <style>
        :root {
            --primary: #1a1a2e;
            --secondary: #16213e;
            --accent: #0f3460;
            --highlight: #e94560;
            --text: #f5f5f5;
            --grid: #2a2a4e;
            --success: #4CAF50;
            --warning: #ff9800;
            --covered: rgba(76, 175, 80, 0.3);
            --uncovered: rgba(233, 69, 96, 0.3);
            --lattice-point: #00bcd4;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .header {
            background: rgba(15, 52, 96, 0.5);
            backdrop-filter: blur(10px);
            padding: 20px;
            text-align: center;
            border-bottom: 2px solid var(--highlight);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, var(--highlight), #00bcd4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            font-size: 1.2em;
            color: rgba(245, 245, 245, 0.8);
            margin-bottom: 10px;
        }

        .main-container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .control-panel {
            background: rgba(22, 33, 62, 0.8);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-group {
            display: inline-block;
            margin-right: 30px;
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: rgba(245, 245, 245, 0.9);
        }

        .control-group input[type="number"],
        .control-group select {
            width: 120px;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(42, 42, 78, 0.7);
            color: var(--text);
            font-size: 14px;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background: linear-gradient(45deg, var(--highlight), #ff6b6b);
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(233, 69, 96, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .visualization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: rgba(22, 33, 62, 0.8);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel h3 {
            margin-bottom: 15px;
            color: var(--highlight);
            font-size: 1.3em;
        }

        canvas {
            width: 100%;
            max-width: 100%;
            height: auto;
            border-radius: 5px;
            background: rgba(26, 26, 46, 0.9);
            margin-bottom: 10px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: rgba(15, 52, 96, 0.4);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: var(--highlight);
        }

        .stat-label {
            font-size: 0.9em;
            color: rgba(245, 245, 245, 0.7);
            margin-top: 5px;
        }

        .uncovered-list {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(26, 26, 46, 0.5);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-family: monospace;
        }

        .formula-display {
            background: rgba(26, 26, 46, 0.7);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            border-left: 3px solid var(--highlight);
        }

        .export-panel {
            background: rgba(15, 52, 96, 0.4);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .export-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        #statusMessage {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            display: none;
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid var(--success);
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }

        .info-panel {
            background: rgba(15, 52, 96, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 3px solid var(--warning);
        }

        .tab-container {
            margin-top: 20px;
        }

        .tab-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .tab-button {
            padding: 10px 20px;
            background: rgba(42, 42, 78, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text);
            cursor: pointer;
            border-radius: 5px 5px 0 0;
            transition: all 0.3s;
        }

        .tab-button.active {
            background: rgba(233, 69, 96, 0.3);
            border-bottom: 2px solid var(--highlight);
        }

        .tab-content {
            display: none;
            padding: 20px;
            background: rgba(26, 26, 46, 0.5);
            border-radius: 0 5px 5px 5px;
        }

        .tab-content.active {
            display: block;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--highlight);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(42, 42, 78, 0.7);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--highlight), var(--warning));
            transition: width 0.3s;
        }

        @media (max-width: 768px) {
            .visualization-grid {
                grid-template-columns: 1fr;
            }
            
            .control-group {
                display: block;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>The 6ab±a±b Problem</h1>
        <div class="subtitle">Sierpiński's Conjecture via Modular Lattice Theory</div>
        <div style="color: rgba(245, 245, 245, 0.6); font-size: 0.9em;">
            Interactive explorer for integers expressible as 6ab + a + b, 6ab + a - b, 6ab - a + b, or 6ab - a - b
        </div>
    </div>

    <div class="main-container">
        <div class="control-panel">
            <h3 style="margin-bottom: 15px; color: var(--highlight);">Analysis Parameters</h3>
            <div class="control-group">
                <label>Max N (Range)</label>
                <input type="number" id="maxN" value="100" min="10" max="10000">
            </div>
            <div class="control-group">
                <label>Max a,b Values</label>
                <input type="number" id="maxAB" value="20" min="5" max="100">
            </div>
            <div class="control-group">
                <label>Visualization Mode</label>
                <select id="vizMode">
                    <option value="coverage">Coverage Map</option>
                    <option value="lattice">Modular Lattice</option>
                    <option value="density">Density Analysis</option>
                    <option value="forms">Form Distribution</option>
                </select>
            </div>
            <div class="control-group">
                <label>Color Scheme</label>
                <select id="colorScheme">
                    <option value="default">Default</option>
                    <option value="heat">Heat Map</option>
                    <option value="forms">By Form</option>
                </select>
            </div>
            <div style="margin-top: 10px;">
                <button onclick="runAnalysis()">Run Analysis</button>
                <button onclick="animateGrowth()">Animate Growth</button>
                <button onclick="findPatterns()">Find Patterns</button>
                <button onclick="compareModuli()">Compare Moduli</button>
            </div>
        </div>

        <div id="statusMessage"></div>

        <div class="visualization-grid">
            <div class="panel">
                <h3>Coverage Visualization</h3>
                <canvas id="coverageCanvas" width="800" height="600"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: var(--success);"></div>
                        <span>Covered</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: var(--highlight);"></div>
                        <span>Uncovered</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: var(--lattice-point);"></div>
                        <span>Multiple Forms</span>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Lattice Structure</h3>
                <canvas id="latticeCanvas" width="800" height="600"></canvas>
                <div class="info-panel">
                    <strong>Visible Residues mod 6:</strong> Φ(6) = {1, 5}<br>
                    <strong>Lattice Points:</strong> (3a±1)(2b±1) where a is even<br>
                    <strong>Parity Restriction:</strong> a = 2k ensures visibility
                </div>
            </div>
        </div>

        <div class="panel">
            <h3>Statistical Analysis</h3>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="totalCovered">0</div>
                    <div class="stat-label">Numbers Covered</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalUncovered">0</div>
                    <div class="stat-label">Numbers Uncovered</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="coveragePercent">0%</div>
                    <div class="stat-label">Coverage Rate</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgRepresentations">0</div>
                    <div class="stat-label">Avg. Representations</div>
                </div>
            </div>
            
            <div class="formula-display">
                <strong>The Four Forms:</strong><br>
                • Form 1: 6ab + a + b<br>
                • Form 2: 6ab + a - b<br>
                • Form 3: 6ab - a + b<br>
                • Form 4: 6ab - a - b
            </div>

            <h4 style="margin-top: 20px; color: var(--warning);">Uncovered Numbers (First 50)</h4>
            <div class="uncovered-list" id="uncoveredList"></div>
        </div>

        <div class="tab-container">
            <div class="tab-buttons">
                <div class="tab-button active" onclick="switchTab('analysis')">Detailed Analysis</div>
                <div class="tab-button" onclick="switchTab('lattice')">Lattice Theory</div>
                <div class="tab-button" onclick="switchTab('patterns')">Pattern Recognition</div>
                <div class="tab-button" onclick="switchTab('export')">Export Data</div>
            </div>

            <div id="analysis" class="tab-content active">
                <h4>Coverage Analysis by Range</h4>
                <canvas id="densityCanvas" width="1200" height="400"></canvas>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar" style="width: 0%;"></div>
                </div>
                <div id="analysisResults"></div>
            </div>

            <div id="lattice" class="tab-content">
                <h4>Modular Lattice Structure</h4>
                <div class="formula-display">
                    <strong>Lattice Construction:</strong><br>
                    L(a,b) = (3a ± 1)(2b ± 1) - 1<br><br>
                    <strong>Parity Restriction:</strong><br>
                    For 3a ± 1 ∈ Φ(6) = {1,5}, we need a ≡ 0 (mod 2)<br>
                    Setting a = 2k gives: 6k ± 1 ≡ ±1 (mod 6)<br><br>
                    <strong>Thin Lattice Property:</strong><br>
                    |Φ(6)| = 2 ≪ 6 → Sparse coverage
                </div>
                <canvas id="modularCanvas" width="1200" height="500"></canvas>
            </div>

            <div id="patterns" class="tab-content">
                <h4>Pattern Recognition</h4>
                <div id="patternResults"></div>
                <canvas id="patternCanvas" width="1200" height="500"></canvas>
            </div>

            <div id="export" class="tab-content">
                <h4>Export Options</h4>
                <div class="export-panel">
                    <div class="export-options">
                        <button onclick="exportJSON()">Export JSON</button>
                        <button onclick="exportCSV()">Export CSV</button>
                        <button onclick="exportLatex()">Export LaTeX</button>
                        <button onclick="exportPython()">Export Python</button>
                        <button onclick="exportImages()">Export Images</button>
                        <button onclick="generateReport()">Generate Full Report</button>
                    </div>
                </div>
                <div id="exportPreview" style="margin-top: 20px;"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentData = {
            covered: new Set(),
            uncovered: [],
            representations: {},
            formCounts: {1: 0, 2: 0, 3: 0, 4: 0},
            densityData: [],
            latticePoints: []
        };

        let animationId = null;
        let isAnimating = false;

        // Initialize on page load
        window.addEventListener('load', () => {
            runAnalysis();
        });

        function runAnalysis() {
            const maxN = parseInt(document.getElementById('maxN').value);
            const maxAB = parseInt(document.getElementById('maxAB').value);
            
            showStatus('Running analysis...', 'info');
            
            // Reset data
            currentData.covered = new Set();
            currentData.representations = {};
            currentData.formCounts = {1: 0, 2: 0, 3: 0, 4: 0};
            currentData.latticePoints = [];
            
            // Generate all values from the four forms
            for (let a = 1; a <= maxAB; a++) {
                for (let b = 1; b <= maxAB; b++) {
                    const forms = [
                        {val: 6*a*b + a + b, form: 1, a: a, b: b},
                        {val: 6*a*b + a - b, form: 2, a: a, b: b},
                        {val: 6*a*b - a + b, form: 3, a: a, b: b},
                        {val: 6*a*b - a - b, form: 4, a: a, b: b}
                    ];
                    
                    forms.forEach(({val, form, a, b}) => {
                        if (val > 0 && val <= maxN) {
                            currentData.covered.add(val);
                            if (!currentData.representations[val]) {
                                currentData.representations[val] = [];
                            }
                            currentData.representations[val].push({form, a, b});
                            currentData.formCounts[form]++;
                        }
                    });
                    
                    // Store lattice points for visualization
                    if (a % 2 === 0) { // Parity restriction
                        currentData.latticePoints.push({a, b});
                    }
                }
            }
            
            // Find uncovered numbers
            currentData.uncovered = [];
            for (let n = 1; n <= maxN; n++) {
                if (!currentData.covered.has(n)) {
                    currentData.uncovered.push(n);
                }
            }
            
            // Calculate density data
            const chunkSize = Math.ceil(maxN / 20);
            currentData.densityData = [];
            for (let i = 0; i < maxN; i += chunkSize) {
                let covered = 0;
                for (let j = i; j < Math.min(i + chunkSize, maxN); j++) {
                    if (currentData.covered.has(j)) covered++;
                }
                currentData.densityData.push({
                    start: i,
                    end: Math.min(i + chunkSize, maxN),
                    coverage: covered / chunkSize
                });
            }
            
            updateStatistics();
            drawVisualizations();
            showStatus('Analysis complete!', 'success');
        }

        function updateStatistics() {
            const maxN = parseInt(document.getElementById('maxN').value);
            const covered = currentData.covered.size;
            const uncovered = currentData.uncovered.length;
            const coverage = ((covered / maxN) * 100).toFixed(1);
            
            let totalReps = 0;
            for (let val in currentData.representations) {
                totalReps += currentData.representations[val].length;
            }
            const avgReps = covered > 0 ? (totalReps / covered).toFixed(2) : 0;
            
            document.getElementById('totalCovered').textContent = covered;
            document.getElementById('totalUncovered').textContent = uncovered;
            document.getElementById('coveragePercent').textContent = coverage + '%';
            document.getElementById('avgRepresentations').textContent = avgReps;
            
            // Update uncovered list
            const list = document.getElementById('uncoveredList');
            list.textContent = currentData.uncovered.slice(0, 50).join(', ') || 'None';
        }

        function drawVisualizations() {
            const mode = document.getElementById('vizMode').value;
            
            switch(mode) {
                case 'coverage':
                    drawCoverageMap();
                    drawLatticeStructure();
                    break;
                case 'lattice':
                    drawLatticeStructure();
                    drawCoverageMap();
                    break;
                case 'density':
                    drawDensityAnalysis();
                    drawLatticeStructure();
                    break;
                case 'forms':
                    drawFormDistribution();
                    drawLatticeStructure();
                    break;
            }
            
            drawModularLattice();
        }

        function drawCoverageMap() {
            const canvas = document.getElementById('coverageCanvas');
            const ctx = canvas.getContext('2d');
            const maxN = parseInt(document.getElementById('maxN').value);
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const cols = Math.ceil(Math.sqrt(maxN));
            const cellSize = Math.min(canvas.width / cols, canvas.height / cols);
            
            for (let n = 1; n <= maxN; n++) {
                const row = Math.floor((n - 1) / cols);
                const col = (n - 1) % cols;
                const x = col * cellSize;
                const y = row * cellSize;
                
                if (currentData.covered.has(n)) {
                    const reps = currentData.representations[n].length;
                    if (reps > 1) {
                        ctx.fillStyle = 'rgba(0, 188, 212, 0.7)';
                    } else {
                        ctx.fillStyle = 'rgba(76, 175, 80, 0.7)';
                    }
                } else {
                    ctx.fillStyle = 'rgba(233, 69, 96, 0.7)';
                }
                
                ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
                
                if (cellSize > 15) {
                    ctx.fillStyle = 'white';
                    ctx.font = `${Math.min(cellSize/3, 12)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(n, x + cellSize/2, y + cellSize/2);
                }
            }
        }

        function drawLatticeStructure() {
            const canvas = document.getElementById('latticeCanvas');
            const ctx = canvas.getContext('2d');
            const maxAB = parseInt(document.getElementById('maxAB').value);
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const padding = 50;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;
            
            // Background grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= 10; i++) {
                const x = padding + (i / 10) * width;
                const y = padding + (i / 10) * height;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, canvas.height - padding);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(canvas.width - padding, y);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.stroke();
            
            // Draw all lattice points with connections
            for (let a = 2; a <= maxAB; a += 2) { // Only even values
                for (let b = 1; b <= maxAB; b++) {
                    const x = padding + (a / maxAB) * width;
                    const y = canvas.height - padding - (b / maxAB) * height;
                    
                    // Calculate the four form values
                    const forms = [
                        6*a*b + a + b,
                        6*a*b + a - b,
                        6*a*b - a + b,
                        6*a*b - a - b
                    ];
                    
                    // Draw connections to neighboring lattice points
                    ctx.strokeStyle = 'rgba(0, 188, 212, 0.15)';
                    ctx.lineWidth = 0.5;
                    
                    // Connect to (a+2, b)
                    if (a + 2 <= maxAB) {
                        const nx = padding + ((a + 2) / maxAB) * width;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(nx, y);
                        ctx.stroke();
                    }
                    
                    // Connect to (a, b+1)
                    if (b + 1 <= maxAB) {
                        const ny = canvas.height - padding - ((b + 1) / maxAB) * height;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x, ny);
                        ctx.stroke();
                    }
                    
                    // Draw lattice point
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, 5);
                    gradient.addColorStop(0, 'rgba(0, 188, 212, 1)');
                    gradient.addColorStop(1, 'rgba(0, 188, 212, 0.3)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Add glow effect for visible points
                    ctx.strokeStyle = 'rgba(0, 188, 212, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            }
            
            // Highlight special points (small a,b values)
            ctx.font = '10px Arial';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let a = 2; a <= Math.min(6, maxAB); a += 2) {
                for (let b = 1; b <= Math.min(5, maxAB); b++) {
                    const x = padding + (a / maxAB) * width;
                    const y = canvas.height - padding - (b / maxAB) * height;
                    ctx.fillText(`(${a},${b})`, x + 8, y - 5);
                }
            }
            
            // Axis labels
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('a (even values only)', canvas.width/2, canvas.height - 10);
            
            // Add axis ticks and values
            ctx.font = '10px Arial';
            for (let a = 0; a <= maxAB; a += Math.ceil(maxAB/10)) {
                if (a % 2 === 0) {
                    const x = padding + (a / maxAB) * width;
                    ctx.fillText(a, x, canvas.height - padding + 15);
                }
            }
            
            for (let b = 0; b <= maxAB; b += Math.ceil(maxAB/10)) {
                const y = canvas.height - padding - (b / maxAB) * height;
                ctx.textAlign = 'right';
                ctx.fillText(b, padding - 5, y + 3);
            }
            
            ctx.save();
            ctx.translate(15, canvas.height/2);
            ctx.rotate(-Math.PI/2);
            ctx.textAlign = 'center';
            ctx.font = 'bold 12px Arial';
            ctx.fillText('b', 0, 0);
            ctx.restore();
            
            // Title
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Modular Lattice: (3a±1)(2b±1) with a even', canvas.width/2, padding - 20);
        }

        function drawDensityAnalysis() {
            const canvas = document.getElementById('densityCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const padding = 40;
            const width = canvas.width - 2 * padding;
            const height = canvas.height - 2 * padding;
            const barWidth = width / currentData.densityData.length;
            
            // Draw axes
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, canvas.height - padding);
            ctx.lineTo(canvas.width - padding, canvas.height - padding);
            ctx.stroke();
            
            // Draw bars
            currentData.densityData.forEach((data, i) => {
                const x = padding + i * barWidth;
                const barHeight = data.coverage * height;
                const y = canvas.height - padding - barHeight;
                
                const gradient = ctx.createLinearGradient(0, y, 0, canvas.height - padding);
                gradient.addColorStop(0, 'rgba(76, 175, 80, 0.8)');
                gradient.addColorStop(1, 'rgba(76, 175, 80, 0.3)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, barWidth - 2, barHeight);
            });
            
            // Labels
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Range', canvas.width/2, canvas.height - 10);
            ctx.save();
            ctx.translate(10, canvas.height/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Coverage Rate', 0, 0);
            ctx.restore();
        }

        function drawFormDistribution() {
            const canvas = document.getElementById('coverageCanvas');
            const ctx = canvas.getContext('2d');
            const maxN = parseInt(document.getElementById('maxN').value);
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw pie chart for form distribution
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) / 3;
            
            const total = Object.values(currentData.formCounts).reduce((a, b) => a + b, 0);
            if (total === 0) return;
            
            const colors = [
                'rgba(233, 69, 96, 0.8)',
                'rgba(76, 175, 80, 0.8)',
                'rgba(0, 188, 212, 0.8)',
                'rgba(255, 152, 0, 0.8)'
            ];
            
            let currentAngle = -Math.PI / 2;
            
            Object.entries(currentData.formCounts).forEach(([form, count], i) => {
                const sliceAngle = (count / total) * 2 * Math.PI;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                ctx.lineTo(centerX, centerY);
                ctx.fillStyle = colors[i];
                ctx.fill();
                
                // Label
                const labelAngle = currentAngle + sliceAngle / 2;
                const labelX = centerX + Math.cos(labelAngle) * (radius * 0.7);
                const labelY = centerY + Math.sin(labelAngle) * (radius * 0.7);
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`Form ${form}`, labelX, labelY);
                ctx.font = '12px Arial';
                ctx.fillText(`${((count/total)*100).toFixed(1)}%`, labelX, labelY + 20);
                
                currentAngle += sliceAngle;
            });
        }

        function drawModularLattice() {
            const canvas = document.getElementById('modularCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw mod 6 residue classes
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 150;
            
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI * 2) / 6 - Math.PI / 2;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                // Highlight visible residues (1 and 5)
                if (i === 1 || i === 5) {
                    ctx.fillStyle = 'rgba(76, 175, 80, 0.8)';
                    ctx.beginPath();
                    ctx.arc(x, y, 20, 0, 2 * Math.PI);
                    ctx.fill();
                } else {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(x, y, 20, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(i, x, y);
            }
            
            // Draw connections
            ctx.strokeStyle = 'rgba(0, 188, 212, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const angle1 = (1 * Math.PI * 2) / 6 - Math.PI / 2;
            const angle5 = (5 * Math.PI * 2) / 6 - Math.PI / 2;
            ctx.moveTo(centerX + Math.cos(angle1) * radius, centerY + Math.sin(angle1) * radius);
            ctx.lineTo(centerX + Math.cos(angle5) * radius, centerY + Math.sin(angle5) * radius);
            ctx.stroke();
            
            // Label
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Visible Residues mod 6: Φ(6) = {1, 5}', centerX, canvas.height - 30);
        }

        function animateGrowth() {
            if (isAnimating) {
                stopAnimation();
                return;
            }
            
            isAnimating = true;
            const button = event.target;
            button.textContent = 'Stop Animation';
            
            let n = 10;
            const maxN = 1000;
            const step = 10;
            
            function animate() {
                if (n > maxN || !isAnimating) {
                    stopAnimation();
                    return;
                }
                
                document.getElementById('maxN').value = n;
                runAnalysis();
                updateProgressBar((n / maxN) * 100);
                
                n += step;
                animationId = requestAnimationFrame(() => setTimeout(animate, 100));
            }
            
            animate();
        }

        function stopAnimation() {
            isAnimating = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            const button = document.querySelector('button[onclick="animateGrowth()"]');
            if (button) button.textContent = 'Animate Growth';
        }

        function findPatterns() {
            showStatus('Analyzing patterns...', 'info');
            
            const results = [];
            const uncovered = currentData.uncovered;
            
            // Check for arithmetic progressions
            const gaps = [];
            for (let i = 1; i < uncovered.length; i++) {
                gaps.push(uncovered[i] - uncovered[i-1]);
            }
            
            // Find common gaps
            const gapCounts = {};
            gaps.forEach(gap => {
                gapCounts[gap] = (gapCounts[gap] || 0) + 1;
            });
            
            const commonGaps = Object.entries(gapCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            
            results.push(`<strong>Most Common Gaps:</strong> ${commonGaps.map(([gap, count]) => `${gap} (${count}x)`).join(', ')}`);
            
            // Check modular patterns
            const modPatterns = {};
            for (let m = 2; m <= 12; m++) {
                modPatterns[m] = {};
                uncovered.forEach(n => {
                    const r = n % m;
                    modPatterns[m][r] = (modPatterns[m][r] || 0) + 1;
                });
            }
            
            results.push(`<strong>Modular Patterns:</strong>`);
            for (let m in modPatterns) {
                const dominant = Object.entries(modPatterns[m])
                    .sort((a, b) => b[1] - a[1])[0];
                if (dominant && dominant[1] > uncovered.length * 0.3) {
                    results.push(`  mod ${m}: ${dominant[0]} appears ${dominant[1]} times`);
                }
            }
            
            const patternDiv = document.getElementById('patternResults');
            if (patternDiv) {
                patternDiv.innerHTML = results.join('<br>');
            }
            
            showStatus('Pattern analysis complete!', 'success');
        }

        function compareModuli() {
            showStatus('Comparing different moduli...', 'info');
            
            const moduli = [6, 30, 210];
            const comparison = [];
            
            moduli.forEach(m => {
                const phi = [];
                for (let i = 1; i < m; i++) {
                    if (gcd(i, m) === 1) phi.push(i);
                }
                
                comparison.push({
                    modulus: m,
                    phiSize: phi.length,
                    density: phi.length / m
                });
            });
            
            const results = comparison.map(({modulus, phiSize, density}) => 
                `<strong>Mod ${modulus}:</strong> |Φ(${modulus})| = ${phiSize}, density = ${(density * 100).toFixed(1)}%`
            ).join('<br>');
            
            const analysisDiv = document.getElementById('analysisResults');
            if (analysisDiv) {
                analysisDiv.innerHTML = `<h4>Modular Comparison</h4>${results}`;
            }
            
            showStatus('Comparison complete!', 'success');
        }

        function gcd(a, b) {
            while (b) {
                const temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }

        function switchTab(tabName) {
            const tabs = document.querySelectorAll('.tab-content');
            const buttons = document.querySelectorAll('.tab-button');
            
            tabs.forEach(tab => tab.classList.remove('active'));
            buttons.forEach(btn => btn.classList.remove('active'));
            
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            
            if (tabName === 'patterns') {
                findPatterns();
            }
        }

        function showStatus(message, type = 'info') {
            const status = document.getElementById('statusMessage');
            status.textContent = message;
            status.style.display = 'block';
            
            if (type === 'success') {
                status.style.background = 'rgba(76, 175, 80, 0.2)';
                status.style.borderColor = 'var(--success)';
            } else if (type === 'error') {
                status.style.background = 'rgba(233, 69, 96, 0.2)';
                status.style.borderColor = 'var(--highlight)';
            } else {
                status.style.background = 'rgba(255, 152, 0, 0.2)';
                status.style.borderColor = 'var(--warning)';
            }
            
            setTimeout(() => {
                status.style.display = 'none';
            }, 3000);
        }

        function updateProgressBar(percent) {
            document.getElementById('progressBar').style.width = percent + '%';
        }

        // Export functions
        function exportJSON() {
            const data = {
                parameters: {
                    maxN: parseInt(document.getElementById('maxN').value),
                    maxAB: parseInt(document.getElementById('maxAB').value)
                },
                statistics: {
                    covered: currentData.covered.size,
                    uncovered: currentData.uncovered.length,
                    coverageRate: ((currentData.covered.size / parseInt(document.getElementById('maxN').value)) * 100).toFixed(2)
                },
                uncoveredNumbers: currentData.uncovered,
                representations: currentData.representations,
                formDistribution: currentData.formCounts,
                densityData: currentData.densityData
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            downloadFile(blob, 'sierpinski_6ab_analysis.json');
        }

        function exportCSV() {
            let csv = 'Number,Covered,Form1,Form2,Form3,Form4,Total_Representations\n';
            const maxN = parseInt(document.getElementById('maxN').value);
            
            for (let n = 1; n <= maxN; n++) {
                const covered = currentData.covered.has(n) ? 1 : 0;
                const reps = currentData.representations[n] || [];
                const formCounts = {1: 0, 2: 0, 3: 0, 4: 0};
                
                reps.forEach(({form}) => formCounts[form]++);
                
                csv += `${n},${covered},${formCounts[1]},${formCounts[2]},${formCounts[3]},${formCounts[4]},${reps.length}\n`;
            }
            
            const blob = new Blob([csv], {type: 'text/csv'});
            downloadFile(blob, 'sierpinski_6ab_data.csv');
        }

        function exportLatex() {
            const maxN = parseInt(document.getElementById('maxN').value);
            const covered = currentData.covered.size;
            const uncovered = currentData.uncovered.length;
            
            let latex = `\\documentclass{article}
\\usepackage{amsmath,amssymb}
\\usepackage{array}
\\usepackage{booktabs}

\\title{Analysis of the $6ab \\pm a \\pm b$ Problem}
\\author{Generated by Sierpiński Problem Explorer}
\\date{\\today}

\\begin{document}
\\maketitle

\\section{Parameters}
\\begin{itemize}
    \\item Range: $1 \\leq n \\leq ${maxN}$
    \\item Maximum $(a,b)$ values: ${parseInt(document.getElementById('maxAB').value)}
\\end{itemize}

\\section{Results}
\\begin{table}[h]
\\centering
\\begin{tabular}{lr}
\\toprule
Metric & Value \\\\
\\midrule
Numbers Covered & ${covered} \\\\
Numbers Uncovered & ${uncovered} \\\\
Coverage Rate & ${((covered/maxN)*100).toFixed(2)}\\% \\\\
\\bottomrule
\\end{tabular}
\\end{table}

\\section{The Four Forms}
\\begin{align}
    F_1(a,b) &= 6ab + a + b \\\\
    F_2(a,b) &= 6ab + a - b \\\\
    F_3(a,b) &= 6ab - a + b \\\\
    F_4(a,b) &= 6ab - a - b
\\end{align}

\\section{Uncovered Numbers}
The first 50 uncovered numbers are:
\\[
    ${currentData.uncovered.slice(0, 50).join(', ')}
\\]

\\section{Modular Lattice Interpretation}
The expressions arise from the lattice map:
\\[
    L(a,b) = (3a \\pm 1)(2b \\pm 1) - 1
\\]
where $a$ must be even to ensure $3a \\pm 1 \\in \\Phi(6) = \\{1,5\\}$.

\\end{document}`;
            
            const blob = new Blob([latex], {type: 'text/plain'});
            downloadFile(blob, 'sierpinski_6ab_analysis.tex');
        }

        function exportPython() {
            const code = `#!/usr/bin/env python3
"""
Sierpiński's 6ab±a±b Problem Analysis
Generated by the Interactive Explorer
"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Set, List, Dict, Tuple

def generate_sierpinski_numbers(max_n: int, max_ab: int) -> Tuple[Set[int], List[int]]:
    """Generate numbers expressible as 6ab±a±b."""
    covered = set()
    representations = {}
    
    for a in range(1, max_ab + 1):
        for b in range(1, max_ab + 1):
            forms = [
                6*a*b + a + b,  # Form 1
                6*a*b + a - b,  # Form 2
                6*a*b - a + b,  # Form 3
                6*a*b - a - b   # Form 4
            ]
            
            for i, val in enumerate(forms, 1):
                if 0 < val <= max_n:
                    covered.add(val)
                    if val not in representations:
                        representations[val] = []
                    representations[val].append((a, b, i))
    
    uncovered = [n for n in range(1, max_n + 1) if n not in covered]
    
    return covered, uncovered, representations

def analyze_modular_lattice(max_ab: int) -> List[Tuple[int, int]]:
    """Generate lattice points with parity restriction."""
    lattice_points = []
    for a in range(2, max_ab + 1, 2):  # Even values only
        for b in range(1, max_ab + 1):
            lattice_points.append((a, b))
    return lattice_points

def plot_coverage(covered: Set[int], max_n: int):
    """Visualize coverage of numbers."""
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))
    
    # Coverage map
    coverage = [1 if n in covered else 0 for n in range(1, max_n + 1)]
    ax1.scatter(range(1, max_n + 1), coverage, c=coverage, cmap='RdYlGn', s=10)
    ax1.set_xlabel('Number')
    ax1.set_ylabel('Covered (1) / Uncovered (0)')
    ax1.set_title('Coverage Map for 6ab±a±b')
    
    # Density analysis
    chunk_size = max_n // 20
    densities = []
    positions = []
    for i in range(0, max_n, chunk_size):
        chunk_coverage = sum(1 for n in range(i+1, min(i+chunk_size+1, max_n+1)) if n in covered)
        densities.append(chunk_coverage / chunk_size)
        positions.append(i + chunk_size/2)
    
    ax2.bar(positions, densities, width=chunk_size*0.8, alpha=0.7, color='steelblue')
    ax2.set_xlabel('Range')
    ax2.set_ylabel('Coverage Density')
    ax2.set_title('Coverage Density by Range')
    
    plt.tight_layout()
    plt.savefig('sierpinski_coverage.png', dpi=150)
    plt.show()

# Parameters from analysis
max_n = ${parseInt(document.getElementById('maxN').value)}
max_ab = ${parseInt(document.getElementById('maxAB').value)}

# Run analysis
covered, uncovered, representations = generate_sierpinski_numbers(max_n, max_ab)
lattice_points = analyze_modular_lattice(max_ab)

# Print results
print(f"Analysis for n ≤ {max_n}, a,b ≤ {max_ab}")
print(f"Numbers covered: {len(covered)}")
print(f"Numbers uncovered: {len(uncovered)}")
print(f"Coverage rate: {len(covered)/max_n*100:.2f}%")
print(f"\\nFirst 20 uncovered numbers: {uncovered[:20]}")

# Modular analysis
print(f"\\nModular Lattice Properties:")
print(f"Visible residues mod 6: Φ(6) = {{1, 5}}")
print(f"Lattice points (with parity restriction): {len(lattice_points)}")

# Visualize
plot_coverage(covered, max_n)`;
            
            const blob = new Blob([code], {type: 'text/plain'});
            downloadFile(blob, 'sierpinski_analysis.py');
        }

        function exportImages() {
            const canvases = ['coverageCanvas', 'latticeCanvas', 'densityCanvas', 'modularCanvas'];
            
            canvases.forEach(canvasId => {
                const canvas = document.getElementById(canvasId);
                if (canvas) {
                    canvas.toBlob(blob => {
                        downloadFile(blob, `sierpinski_${canvasId}.png`);
                    });
                }
            });
        }

        function generateReport() {
            const maxN = parseInt(document.getElementById('maxN').value);
            const maxAB = parseInt(document.getElementById('maxAB').value);
            const covered = currentData.covered.size;
            const uncovered = currentData.uncovered.length;
            
            const report = `
SIERPIŃSKI'S 6ab±a±b PROBLEM - ANALYSIS REPORT
==============================================
Generated: ${new Date().toISOString()}

EXECUTIVE SUMMARY
-----------------
This report analyzes integers expressible in the forms 6ab±a±b where a,b are natural numbers.
The problem, posed by Sierpiński in 1964, asks whether infinitely many integers cannot be 
expressed in any of these four forms.

PARAMETERS
----------
• Range analyzed: 1 ≤ n ≤ ${maxN}
• Maximum (a,b) values: ${maxAB}
• Analysis method: Modular Lattice Theory

KEY FINDINGS
------------
• Numbers covered: ${covered} (${((covered/maxN)*100).toFixed(2)}%)
• Numbers uncovered: ${uncovered} (${((uncovered/maxN)*100).toFixed(2)}%)
• Average representations per covered number: ${(Object.values(currentData.representations).reduce((a,b) => a + b.length, 0) / covered).toFixed(2)}

FORM DISTRIBUTION
-----------------
Form 1 (6ab + a + b): ${currentData.formCounts[1]} instances
Form 2 (6ab + a - b): ${currentData.formCounts[2]} instances
Form 3 (6ab - a + b): ${currentData.formCounts[3]} instances
Form 4 (6ab - a - b): ${currentData.formCounts[4]} instances

UNCOVERED NUMBERS (First 100)
------------------------------
${currentData.uncovered.slice(0, 100).join(', ')}

MODULAR LATTICE INTERPRETATION
-------------------------------
The expressions 6ab±a±b arise from the lattice map:
L(a,b) = (3a ± 1)(2b ± 1) - 1

Key insights:
• Parity restriction: a must be even for 3a±1 ∈ Φ(6) = {1,5}
• Thin lattice property: |Φ(6)| = 2 << 6 creates sparse coverage
• This is the critical threshold where coverage might fail

DENSITY ANALYSIS
----------------
${currentData.densityData.map(d => 
    `Range [${d.start}-${d.end}]: ${(d.coverage*100).toFixed(1)}% coverage`
).join('\n')}

THEORETICAL CONTEXT
-------------------
The mod 6 case represents a "thin modular lattice" with minimal rank and few 
multiplicative directions. In contrast, moduli of the form M = 30·2^n have 
rapidly growing |Φ(M)| where coverage becomes structurally unavoidable.

CONCLUSIONS
-----------
The analysis confirms the sparse coverage predicted by thin lattice theory.
With ${uncovered} uncovered numbers in the range 1-${maxN}, the data supports
the conjecture that infinitely many integers escape all four forms.

REFERENCES
----------
• Sierpiński, W. (1964). Elementary Theory of Numbers
• Modular Lattice Theory and Prime Sieves
• Interactive Explorer: https://github.com/[your-repo]
            `;
            
            const blob = new Blob([report], {type: 'text/plain'});
            downloadFile(blob, 'sierpinski_full_report.txt');
        }

        function downloadFile(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            showStatus(`Downloaded ${filename}`, 'success');
        }
    </script>
</body>
</html>
